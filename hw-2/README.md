# Второ домашно

## Условие на задачата

След невероятния успех на кампанията по продажба на банани и швепс в магазините МразМаг фирмата се разраснала неимоверно. Толкова много, че се наложило да въведат много сложна йерархия на служители, по-малки мениджъри, по-големи мениджъри и шефове. Разбира се главният изпълнителен директор останал един – Петър Петров (по прякор Успешния).

За да успява да следи клоновата си мрежа и всички нейни служители, Успешният помолил своя екип разработчици да му напише програма, която да може да прочита от текст (string) описание на професионални взаимоотношения и след това да построява дърво, което да представя тези връзки (шеф-подчинен). Едно такова дърво описва взаимоотношенията в рамките на един клон на компанията (отдел, магазин и т.н.). Понеже преди да се захване с търговия на дребно, Успешния бил учил малко във ФМИ, той знаел, че когато всеки служител (освен него самия, разбира се) има точно един шеф, то построяване на такова дърво било не само възможно, но и лесно.

## Вход

Програмата ви ще трябва да може да зарежда входа си от един или повече текстови файлове. Всеки един такъв файл съдържа нула, един или повече редове, като всеки ред съдържа описанието на едно взаимоотношение ръководител-подчинен. Например редът &quot;Ivan-Georgi&quot; означава, че Иван е пряк ръководител на Георги.

Имената на хората не съдържат празни символи или тире и всяка такава двойка е на отделен ред. Редът, в който те са подредени при въвеждането не е строго определен, но трябва всеки с роля _ръководител_ първо да се е появил с роля _подчинен_ (освен главният изпълнителен директор, който на никого не е подчинен). Например не може във входа да се срещне ред &quot;Ivan-Georgi&quot;, ако преди това не е имало друг запис, в който да се укаже на кого е подчинен Иван.

Всеки човек се предполага да се среща точно един път в ролята на подчинен в записите. За улесняване на задачата предполагаме, че не може да има двама човека с еднакви имена, като отчитаме разликите между малки и главни букви. Тъй като предполагаме, че в корена на всяко едно такова дърво стои Успешния, за него не добавяме запис - той може да бъде използван директно, за да се укаже кои са преките му подчинени, например &quot;Uspeshnia - Ivan&quot;.

Няма ограничение в дълбочината на дървото, което ще се построи.

## Операции

Освен да зареждате такива данни и да построявате съответните на йерархиите им дървета трябва да можете да извършвате различни операции с тях:

- На първо място трябва да проверите дали подадените ви данни са коректни и ако не са да сигнализирате за това;
- Да можете да проверите дали даден служител е част от дадена йерархия;
- За даден служител трябва да можете да кажете броя на преките му подчинени;
- За даден служител трябва да можете да кажете името на прекия му ръководител;
- За дадена йерархия трябва да можете да кажете броя на всички служители в нея;
- Трябва да намирате броя на всички ръководители, които са претоварени - имат повече от N подчинени (преки или не). N е параметър на операцията;
- Трябва да може да обединявате две дървета (представящи йерархии от два отдела). Това да става по следната схема:
  - Ако служител се среща и в двете йерархии, то в обединението той също се среща като там преките му подчинени са всички негови преки подчинени от двете йерархи. Предполага се Успешният да е на върха и на двете места. Това правило се прилага рекурсивно надолу (за всички служители от върха надолу). Ако в двата отдела този служител има различни ръководители, то в обединението трябва да остане само една инстанция, закачена към по-високо стоящия в йерархията ръководител. Ако двата са на едно ниво (например преки подчинени на Успешния), то изберете този с лексикографски по-малкото име. Не се предполага за двама служители в едната йерархия единият да е подчинен на другия, а в другата - обратно;
  - Ако даден служител се среща само в едната йерархия, той присъства в обединението, точно под инстанцията на ръководителя си (като негов пряк подчинен), заедно с всички свои подчинени от съответното дърво;
  - Сливането не е възможно ако има ситуация, в която служител X е подчинен на Y в едната йерархия (пряко или не), а в другата е обратно. В такъв случай не трябва да създавате слятата йерархия.
- По подадена йерархия и име на служител трябва да уволните (премахнете) служителя, като всички негови подчинени стават съответно подчинени на ръководителя му. Разбира се, няма как да се уволни Успешния;
- По подадена йерархия, име на служител и име на ръководител трябва да назначите служителя като подчинен на този ръководител. Проверете дали служителят вече не работи с друг ръководител. Тогава преместете служителя на новата му позиция (преназначаване). Ако в този случай служителят е имал подчинени, то те остават под него в йерархията;
- Трябва да можете да записвате дърво в символен низ (string). Форматът е описан по-подробно в следващия раздел на документа;
- За една фирма трябва да можете да кажете от колко човека се състои най-дългата верига от отношения ръководител-подчинен;
- Трябва да може да смятате заплатата на даден служител, като тя се определя по следната формула: 500 \* \&lt;брой преки подчинени> + 50 \* \&lt;брой не преки подчинени>;
- Трябва да може да инкорпорирате една йерархия. Това става като за всеки екип (множество служители с общ пряк ръководител), който има поне двама служителя, се избере служителят с най-висока заплата и се направи шеф на този екип. Ако този служител има собствени подчинени, те остават в неговия екип. Ако има повече от един такъв служител, да се избере този с лексикографски най-малкото име. Инкорпорирането започва от най-ниските нива в йерархията. На фигурата по-долу е показана йерархия преди инкорпориране и съответно след. В първоначалната йерархия са подчертани със зелено екипите и с червено служителят, който ще бъде повишен.

![alt text](https://i.imgur.com/p7zx5fc.png)

- Трябва да може да модернизирате една фирма. Това става като за всеки ръководител на нечетно ниво спрямо Успешния, неговият екип се слее с екипа на по-висшия ръководител. Ръководителят се премахва. Модернизацията започва от най-ниските нива на йерархията.

## Представяне на дърво като символен низ.

Всяко дърво от разглеждания тип може да се представи като редица от двойки от вид _ръководител-подчинен_. В редицата те трябва да са подредени по следния начин:

1. Старшинство (от най-висшия към по-нисшите ръководители).
2. Записите, в които има двама ръководители от едно ниво на йерархията, се подреждат лексикографски – най-напред по името на ръководителя, а когато то съвпада за два различни записа, по името на служителя.

Всяка двойка ръководител-подчинен се представя като низ като конкатенираме техните имeнa със символа тире и завършва със символа за нов ред. Дървото представяме като конкатенация на всички такива двойки. Например за лявото дърво от фигурата по-горе, ще имаме следното представяне:

&quot;Uspeshnia-Gosho\nUspeshnia-Misho\nUspeshnia-Slavi\nGosho-Dancho\nGosho-PeshonSlavi-Slav1\nSlavi-Slav2\nDancho-Boris\nDancho-Kamen\nPesho-Alex\nSlav1-Mecho\nMecho-Q12Adl\n&quot;

Което, за по-лесно, даваме по-долу и така както би изглеждал след извеждане на екрана:
```
Uspeshnia-Gosho
Uspeshnia-Misho
Uspeshnia-Slavi
Gosho-Dancho
Gosho-Pesho
Slavi-Slav1
Slavi-Slav2
Dancho-Boris
Dancho-Kamen
Pesho-Alex
Slav1-Mecho
Mecho-Q12Adl
```
## Операции

Програмата, която реализирате, трябва да има интерактивен конзолен потребителски интерфейс, в който да се поддържат всички гореизброени функционалности. Ако нещо не е наред (грешен формат на данните, не е намерен посочен файл и др.) програмата ви трябва да продължи да работи коректно и трябва да изведете на екрана подходящо съобщение за потребителя.

Командите, които трябва да обработвате (като минимум) са:

- `help` – извежда списък на поддържаните команди с кратка помощна информация за тях;
- `load` `име\_на\_обект` `име\_на\_файл` – зарежда данни за йерархия от файл с подаденото име и създава дърво, асоциирано с име\_на\_обект. Това име трябва да се състои само от малки и главни латински букви, цифри и символ за подчертаване. След него всичко до края на реда е името на файла от който трябва да прочетете данните в описания по-горе формат. Ако името на файла липсва се предполага да прочетете данните от стандартния вход, до срещане на край на файл (ctrl+z/ctrl+d);
- `save`` име\_на\_обект` `име\_на\_файл` – записва информацията за йерархията на посочения обект във файл с посоченото име. Ако името на файла е празно, информацията да се изведе на стандартния изход;
- `find` `име\_на\_обект` `име\_на\_служител` – проверява дали в посочения обект съществува служител с посоченото име;
- `num_subordinates` `име\_на\_обект` `име\_на\_служител` – извежда броя преки подчинени на дадения служител в посочения обект;
- `manager` `име\_на\_обект` `име\_на\_служител` – извежда името на ръководителя на дадения служител в посочения обект;
- `num\_employees` `име\_на\_обект` – извежда броя служители в посочения обект;
- `overloaded` `име\_на\_обект` – извежда броя служители в посочения обект, за които броят подчинени (преки или не) е по-голям от 20;
- `join` `име\_на\_обект\_1` `име\_на\_обект\_`2 `име\_на\_обект\_резултат` – обединява двата подадени обекта в нов обект с име име\_на\_обект\_резултат;
- `fire` `име\_на\_обект` `име\_на\_служител`– премахва служителя от съответния обект;
- `hire` `име\_на\_обект` `име\_на\_служител` `име\_на\_ръководител` – назначава служителя в съответния обект като подчинен на подадения ръководител;
- `salary` `име\_на\_обект` `име\_на\_служител` – извежда заплатата на служителя;
- `incorporate` `име\_на\_обект` – инкорпорира фирмата; операцията се прилага върху обекта име\_на\_обект;
- `modernize` `име\_на\_обект` – модернизира фирмата; операцията се прилага върху обекта име\_на\_обект;
- `exit` - прекратява изпълнението на програмата. За всички нови или променени след зареждането обекти попитайте потребителя дали иска да ги запази във файл.

## Примерно изпълнение на програмата
```
> load Lozenec
Uspeshnia - Gosho
Uspeshnia - Misho
Gosho - Pesho
Gosho - Dancho
Pesho - Alex
Dancho-Boris
Dancho-Kamen
Uspeshnia - Slavi
Slavi - Slav1
Slavi - Slav2
Slav1-Mecho
Mecho-Q12Adl
^Z
Lozenec loaded successfully!
```
```
> find Lozenec Alex
Alex is employed in Lozenec.
```
```
> num_subordinates Lozenec Alex
Alex has no subordinates.
```
```
> num_subordinates Lozenec Slavi
Slavi has two subordinates.
```
```
> manager Lozenec Slav1
The manager of Slav1 is Slavi.
```
```
> manager Lozenec Slav3
There is no Slav3 in Lozenec.
```
```
> num_employees Lozenec
There are 13 employees in Lozenec.
```
```
> num_employees Lozenec2
Lozenec2 is an unknown office!
```
```
> overloaded Lozenec
No overloaded employees in Lozenec.
```
```
> load Lozenec_new
Uspeshnia - MishoPetrov
MishoPetrov - Misho
MishoPetrov - Slav
^Z
Lozenec_new loaded successfully!
```
```
> join Lozenec Lozenec\_new LozBig
LozBig created.
```
```
> save LozBig LozBig.data
LozBig saved.
```
```
> manager LozBig Misho
The manager of Misho is Uspeshnia.
```
```
>num\_subordinates LozBig MishoPetrov
MishoPetrov has one subordinates.
```
```
> fire LozBig MishoPetrov
MishoPetrov was fired.
```
```
> num\_subordinates LozBig Uspeshnia
Uspeshnia has four subordinates.
```
```
> save LozBig LozBig.data
LozBig saved.
```
```
> hire Lozenec MishoPetrov Misho
MishoPetrov was hired.
```
```
> salary Lozenec Gosho
The salary is 1150 BGN.
```
```
> hire Lozenec_new Mitko Uspeshnia
Mitko was hired.
```
```
> hire Lozenec_new MishoPetrov Mitko
MishoPetrov was hired.
```
```
> incorporate Lozenec_new
Lozenec_new incorporated.
```
```
> save Lozenec_new
Uspeshnia-Mitko
Mitko-MishoPetrov
MishoPetrov-Misho
Misho-Slav
```
```
> hire Lozenec_new Ivan Misho
Ivan was hired.
```
```
> hire Lozenec_new Stojan Ivan
Stojan _was hired.
```
```
> modernize Lozenec_new
Lozenec_new modernized.

> save Lozenec_new
Uspeshnia-MishoPetrov
MishoPetrov-Ivan
MishoPetrov-Slav
Ivan-Stojan
```
```
> save Lozenec_new loz.data
Lozenec_new saved.
```
```
> exit
Lozenec is modified, but not saved.
Enter file name to save it:
```
```
> lozenec.data
Lozenec saved.
Goodbye
```
## Тестове
В `tests/tests.cpp` се намират unit тестовете на програмата.

## Компилиране
За да се пуснат тестовете - компилирате заедно `implementation.cpp`, `validator.cpp` и `tests.cpp`.

За конзолно приложение - компилирате заедно `implementation.cpp`, `validator.cpp` и `main.cpp`.